# Задача

Написать программу gentree используя PHP7.1, генерирующую JSON файл на основе входящего CSV файла.

## Данные

Программа принимает в качестве параметров командной строки:

1) Путь к входящему файлу в формате CSV (input.csv)

2) Путь для выгружаемого файла (output.json)

## Описание

1) Файл input.csv - это пример файла который будет передан в программу. 
В нем находится дерево в табличном представлении. 
Связь ребенок-родитель между элементами осуществляется через колонки Item Name и Parent.
Колонка Item Name содержит уникальные имена элементов. 
Дерево имеет 3 типа элементов (см. колонку Type): 'Изделия и компоненты','Варианты комплектации','Прямые компоненты'.

2) Каждый элемент типа 'Прямые компоненты' имеет возможное продолжение через связь с элементом типа 
'Изделия и компоненты', эта связь указана в колонке 'Relation'. Необходимо построить продолжение дерева, присоединив к каждому элементу типа 'Прямые компоненты' ветку элемента типа 'Изделия и компоненты' используя эту связь.
В результате должно получится дерево представленное в прикрепленном к заданию output.json, которое необходимо сохранить на диск.

3) Тип элементов 'Варианты комплектации' не используется в генерации веток через колонку 'Relation', для них значение колонки Relation всегда пустое, но они присутствуют как элементы дерева при генерации связей через 'Прямые компоненты' и 'Изделия и компоненты' (пункт 2), далее в примере и в прикрепленном файле output.json можно это увидеть.

## Пример построения дерева

Рассмотрим небольшой кейс на примере самого первого элемента типа 'Прямые компоненты', видим вот такую исходную ветку:

- Total
    - ПВЛ
        - Стандарт.#1
            - Тележка Б25.#2
            
Элемент 'Тележка Б25.#2' имеет тип 'Прямые компоненты' и согласно колонке 'Relation' имеет связь с элементом 'Тележка Б25' типа 'Изделия и компоненты'
Значит необходимо к элементу 'Тележка Б25.#2' присоединить дерево которое входит в элемент 'Тележка Б25', получаем:

- Total
    - ПВЛ
        - Стандарт.#1
            - Тележка Б25.#2
                - Стандарт.#5
                    - РБ ЦДЛР.9855.00.02.000.#17
                    - БН ЦДЛР.9855.00.01.000.#18
                    - Колесная пара 25 т.#19
                ... <- мы опустили дальше элементы для уменьшения кейса с примером
                
Получив такое дерево, мы должны продолжить его генерацию дальше, так элемент 'РБ ЦДЛР.9855.00.02.000.#17' имеет связь с элементом 'РБ ЦДЛР.9855.00.02.000' через колонку 'Relation', а элемент 'БН ЦДЛР.9855.00.01.000.#18' с 'БН ЦДЛР.9855.00.01.000' и элемент 'Колесная пара 25 т.#19' с 'Колесная пара 25 т'
Достраиваем ветки и получаем:

- Total
    - ПВЛ
        - Стандарт.#1
            - Тележка Б25.#2
                - Стандарт.#5
                    - РБ ЦДЛР.9855.00.02.000.#17
                    - БН ЦДЛР.9855.00.01.000.#18
                    - Колесная пара 25 т.#19
                        - Стандарт.#10
                            - Колесо 25т.#52
                            - Ось 25т.#53
                ... 
                            
Далее пробуем подцепить к 'Колесо 25т.#52' и 'Ось 25т.#53' продолжение как ранее мы сделали с 'Колесная пара 25 т.#19', но из-за отсутствия веток в 'Колесо 25т' и 'Ось 25т' мы останавливаемся и переходим к другим элементам продолжая генерацию дерева пока не достигнем для каждой ветки дерева конца из-за отсутствия вложенности у элементов типа 'Изделия и компоненты'

Пример полной генерации смотри в файле output.json который прикреплен к заданию

## Дополнения

- Входящий CSV файл в кодировке UTF-8, разделитель точка с запятой, экранирование двойными кавычками

- Алгоритм должен быть универсален и учитывать любое кол-во входящих строк, но максимально ожидаемый объем входящего файла можно ограничить проверкой на 20 тыс строк

- Колонки входящего файла строго фиксированы, файл всегда имеет 4 колонки вида и порядка представленном в input.csv

- Входящие данные гарантируют отсутствие бесконечных рекурсий

- Исходящий JSON файл в кодировке UTF-8

## Требования к проекту 

Решение представить в виде архива с исходным кодом на PHP 7.1, либо в виде ссылки на онлайн Git-репозиторий

Код должен собираться и запускаться под Ubuntu/Debian, а так же иметь README по сборке и запуску.

## Критерии оценки решения

1) Качество архитектуры приложения и читабельность кода, легкость дальнейшего развития и поддержки, уровень абстрактности кода, уровень модульности, качество применения ООП. (Решения в виде портянки кода в одном файле не будут рассматриваться)

2) Правильность выдаваемых результатов и наличие тестов

3) Скорость работы и потребление памяти

# Комментарии к решению

## Запуск из консоли

php gentree.php - основной файл

php gentree_test_result.php - дополнительный проверяющий файл

## Куда пропали параметры вызова

В задании требуется возможность задавать пути к файлам в параметрах вызова. Но нет уточнений, могут ли в принципе эти пути быть вшиты в конфигурацию (например, при автоматизированной работе такого скрипта на сайте было бы именно так). Т.е., "есть параметры - берё их, нет параметров - берём из конфигурации". 

Кроме того, нет пояснений, как именно читать параметры - как абсолютные пути, или как относительные пути, и если как относительные, то относительно какой папки. 

Наконец, может ли юзер быть вредоносным и ввод параметров превратить в борьбу с сервером: надо ли проверять в параметрах ограниченность снизу и сверху числа символов, проверять типы символов и др.

При любой конкретизации по этим вопросам довесок к скрипту пишется очень быстро. Но принимать решения по конкретизации самостоятельно я не берусь - я в данном случае исполнитель. В подобных задачах мне нужна детализация требований.

Поскольку сама я делала этот скрипт на основе конкретных наборов файлов (исходно были нынешние data/full/input.csv и data/full/output_correct.json, из которых я сделала краткую и среднюю версии), пути к ним в данной реализации зашиты хардкодом в основной скрипт gentree.php . В коде этого файла можно выбрать подпапку $base: short, medium или full версии файлов.

## Тесты

Вообще говоря, файл gentree_test_result.php на тесты не тянет. На юнит-тесты. Это глобальный тест по всему проекту, к тому же совсем не похожий по выдаче на PHPUnit. Но он мне помог в разработке класса App\Tree\TreeBuilder. В частности, мне удобнее было построчно читать итоговый мой и "хороший" итоговый тестовый файл и сравнивать их, выводя в консоли строку, где впервые встретились расхождения. Больше мне ничего в консоли было не нужно.

В итоге имеем несколько прозрачных классов и интерфейсов (для чтения и для записи файлов, а также класс с данными App|Tree\Tree), прозрачный код скриптов gentree.php и gentree_test_result.php и средней мутности класс App\Tree\TreeBuilder, использующий хеш-таблицы и ссылочную передачу данных. Единственный класс, который бы стоило здесь обвешивать юнит-тестами - класс App\Tree\TreeBuilder.

Но, к сожалению, я плоховато пока понимаю предметную область, чтобы красиво написать входящие данные для маленького PHPUnit-теста к этому классу. Который бы хорошо (т.е., быстро, быстрее всего) проходил в палитре из тысячи тестов рядом. Есть очень длинный исходный csv-файл, из которого мне удалось достать укороченные варианты, помогавшие при разработке, однако я не уверена, что csv на 380 строк (именно столько строк в исходном тестовом data/full/input.csv) - ок для тестов. А про мой собственный средний data/medium/input.csv я не уверена, что он проверяет уже всё, что требуется.

Если императивно необходимы именно юнит-тесты, я написала бы ровно один, но предложила бы знающим в предметной области написать минимальной длины csv (и соответствующий ему json), на котором возможно точно проверить работу класса App\Tree\TreeBuilder. Дальше сам тест уже пишется за минимальное время.

Файл gentree_test_result.php вызывается как обычный php-скрипт, из консоли, в папке проекта:

php gentree_test_result.php

## Окончания строк в csv файле

Исходно в классе App\Readers\CSVReader я заменяла окончания строк на пустую строку через поиск подстрок вида "\n":

$string = str_replace("\n", '', $string);

С тестовым файлом из zip-папки задания это работало. Однако после выкладки на гитхаб и пулла обратно на свой компьютер я обнаружила, что эта замена перестала работать. Гитхаб изменил символы окончания. Вернее, он изменил что-то - что именно, я не знаю. Сработала замена кода на 

$string = str_replace(PHP_EOL, '', $string);